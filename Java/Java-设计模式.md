[toc]

## [设计模式](https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528)

设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。

为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的，它基于以下几个原则：

* **开闭原则:**在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。
* **里氏替换原则:**如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。



---

### 创建型模式

创建型模式关注点是如何创建对象，**其核心思想是要把对象的创建和使用相分离**，这样使得两者能相对独立地变换。

创建型模式包括：

- 工厂方法：Factory Method
- 抽象工厂：Abstract Factory
- 建造者：Builder
- 原型：Prototype
- 单例：Singleton

#### Factory Method

[](images/FactoryDesignPatten.png)

```ascii
┌─────────────┐      ┌─────────────┐
│   Product   │      │   Factory   │	// Interface
└─────────────┘      └─────────────┘
       ▲                    ▲
       │                    │
┌─────────────┐      ┌─────────────┐
│ ProductImpl │<─ ─ ─│ FactoryImpl │	// Implementation of Interface
└─────────────┘      └─────────────┘
```

* 通常我们会在接口`Factory`中定义一个静态方法`getFactory()`来返回真正的子类

* 简化的使用静态方法创建产品的方式称为静态工厂方法（Static Factory Method）。静态工厂方法广泛地应用在Java标准库中。

  ```java
  Integer n = Integer.valueOf(100);
  ```

* 工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。

  如果调用方直接使用 `Integer n = new Integer(100)`，那么就失去了使用缓存优化的可能性。

* 总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。

  ```java
  // 和List.of()类似，我们使用MessageDigest时，为了创建某个摘要算法，总是使用静态工厂方法getInstance(String)：
  MessageDigest md5 = MessageDigest.getInstance("MD5");
  MessageDigest sha1 = MessageDigest.getInstance("SHA-1");
  ```



#### Abstract Method

> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。



#### Builder

> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。



#### Prototype

> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。



#### Singleton

> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

单例模式的实现方式很简单：

1. 只有`private`构造方法，确保外部无法实例化；
2. 通过`private static`变量持有唯一实例，保证全局唯一性；
3. 通过`public static`方法返回此唯一实例，使外部调用方能获取到实例。

Java标准库有一些类就是单例，例如`Runtime`这个类：

```
Runtime runtime = Runtime.getRuntime();
```



---

### 结构型模式

结构型模式主要涉及如何组合各种对象以便获得更好、更灵活的结构。虽然面向对象的继承机制提供了最基本的子类扩展父类的功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。

结构型模式有：

- 适配器
- 桥接
- 组合
- 装饰器
- 外观
- 享元
- 代理



#### 适配器

#### 桥接

#### 组合

#### 装饰器

#### 外观

### 享元

#### 代理



---

### 行为型模式

行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。

行为型模式有：

- 责任链
- 命令
- 解释器
- 迭代器
- 中介
- 备忘录
- 观察者
- 状态
- 策略
- 模板方法
- 访问者



#### 责任链

#### 命令

#### 解释器

#### 迭代器

#### 中介

#### 备忘录

#### 观察者

#### 状态

#### 策略

#### 模板方法

#### 访问者

